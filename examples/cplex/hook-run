#!/bin/bash
###############################################################################
# This hook is to tune the CPLEX software.
#
# PARAMETERS:
# $1 is the instance name  
# $2 is the candidate number
# The rest ($* after `shift 2') are parameters to the run of CPLEX
#
# RETURN VALUE:
# This hook should print a single numerical value (the value to be minimized)
###############################################################################

EXE=/opt/ibm/ILOG/CPLEX_Studio124/cplex/bin/x86-64_sles10_4.1/cplex #cluster
#EXE=/opt/ibm/ILOG/CPLEX_Studio124/cplex/bin/x86_sles10_4.1/cplex #MYPC

#check units for this
#MEMORY_LIMIT=$(( 3072 * 1024 * 1024 ))
MEMORY_LIMIT=900

# The instance name and the candidate id are the first parameters
INSTANCE=$1
CANDIDATE=$2
RUNTIME_LIMIT=10000
PENALTY=$(( $RUNTIME_LIMIT ))

# All other parameters are the candidate parameters to be passed to ACOTSP
shift 2 || exit 1
CAND_PARAMS=$*

NRAND=$RANDOM

STDOUT="c${CANDIDATE}-${NRAND}.stdout"
STDERR="c${CANDIDATE}-${NRAND}.stderr"
STDPAR="c${CANDIDATE}-${NRAND}.stdpar"

WORK_DIR="c${CANDIDATE}-${RANDOM}"

cat <<EOF > $STDPAR
set logfile *
read $INSTANCE
set clocktype 1
set threads 1
set timelimit $RUNTIME_LIMIT
set mip limits treememory $MEMORY_LIMIT
set workdir $WORK_DIR
set mip tolerances mipgap 0
EOF

i=0
SIMPLEX_PER_S="no"
PERTURB_CONS="1e-6" #default value for option simple perturbation switch no

IFS=" "

for ELEMENT in $CAND_PARAMS; do
    mod=$(( $i % 2 ))
    if [ "$mod" -eq "0" ]; then
      PNAME=${ELEMENT//'_'/' '}
    else
      if [ "$PNAME" == "mip strategy bbinterval" ]; then
         if [ "$ELEMENT" -eq "0" ]; then
            ELEMENT=1000
         fi
      fi

      if [ "$PNAME" == "simplex perturbation switch" ]; then
          SIMPLEX_PER_S=$ELEMENT
      elif [ "$PNAME" == "perturbation constant" ]; then
          PERTURB_CONS=$ELEMENT
      else
          echo "set $PNAME $ELEMENT" >> $STDPAR
      fi
    fi
    i=$(( $i + 1))
done

cat <<EOF >> $STDPAR
set simplex perturbation ${SIMPLEX_PER_S} ${PERTURB_CONS}
display settings all
opt
quit
EOF

#echo "./hook-run ${INSTANCE} ${CANDIDATE} ${RUNTIME_LIMIT} ${CAND_PARAMS}" >> "check.txt"

$EXE < ${STDPAR} 1> ${STDOUT} 2> ${STDERR}

# In case of error, we print the current time:
error() {
    echo "`TZ=UTC date`: error: $@" >&2
    exit 1
}

# The output of the candidate $CANDIDATE should be written in the file 
if [ ! -s "${STDOUT}" ]; then
    # In this case, the file does not exist. Let's exit with a value 
    # different from 0. In this case irace will stop with an error.
    error "${STDOUT}: No such file or directory"
fi

SOLVED="CRASHED"

# FIXME: This could use case and avoid read STDOUT so many times.
TMP=$(cat ${STDOUT} | grep "Error termination")
if [ "$TMP" != "" ]; then
    SOLVED="TIMEOUT"
fi

TMP=$(cat ${STDOUT} | grep "MIP - Time limit exceeded")
if [ "$TMP" != "" ]; then
    SOLVED="TIMEOUT"
fi

TMP=$(cat ${STDOUT} | grep "MIP - Aborted")
if [ "$TMP" != "" ]; then
    SOLVED="TIMEOUT"
fi

TMP=$(cat ${STDOUT} | grep "MIP - Memory limit exceeded")
if [ "$TMP" != "" ]; then
    SOLVED="TIMEOUT"
fi

TMP=$(cat ${STDOUT} | grep "runsolver_max_cpu_time_exceeded")
if [ "$TMP" != "" ] ; then
    SOLVED="TIMEOUT"
fi

TMP=$(cat ${STDOUT} | grep "runsolver_max_memory_limit_exceeded")
if [ "$TMP" != "" ] ; then
    SOLVED="TIMEOUT"
fi

TMP=$(cat ${STDOUT} | grep "MIP - Integer optimal")
if [ "$TMP" != "" ] ; then
    SOLVED="SOLVED"
fi

TMP=$(cat ${STDOUT} | grep "MIP - Optimal")
if [ "$TMP" != "" ] ; then
    SOLVED="SOLVED"
fi

if [ "$SOLVED" == "TIMEOUT" ]; then
    COST=$RUNTIME_LIMIT
elif [ "$SOLVED" == "CRASHED" ]; then
    COST=$PENALTY
else
    # runtime objective
    COST=$(cat ${STDOUT} | grep "Solution time" | gawk -F " " '{print $4}')
    if ! [[ "$COST" =~ ^[-+0-9.e]+$ ]] ; then
        error "${STDOUT}: Output is not a number"
    fi
fi

echo "$COST $COST"

#echo "SCOST: $COST ECOST ./hook-run ${INSTANCE} ${CANDIDATE} ${CAND_PARAMS}" >> "check.txt"

# We are done with our duty. Clean files and exit with 0 (no error).
rm -rf "$WORK_DIR" "${STDOUT}" "${STDERR}" "${STDPAR}"
exit 0
