------------------------------------------------------------*- mode: text -*-

BUGS

#2 

A parameter like:

a "" c (0, 5, 10, 20)

and a constraint like a > 10 will return TRUE when a is 5, because a
is actually "5" so the comparison is lexicographic. How to solve this?

 - Fix 1. Check if a can be converted to numeric, then force it before
   evaluating constraints. However, we cannot know for sure if the user
   actually wants to convert a to numeric or not. Imagine a = "+3", then
   a == "+3" would fail!

 - Fix 2. Force users to use quotes when defining categorical and
   ordinal parameters. Hopefully this will make obvious that these
   values are strings and cannot be compared with other numbers.
 
#1 

$ irace --debug-level
Error in if (configuration$debugLevel >= 1) { : 
  missing value where TRUE/FALSE needed
Calls: irace.cmdline -> irace.main -> checkConfiguration
Execution halted


TODO R package:

 * Read about vignette here: http://cran.r-project.org/doc/manuals/R-exts.html#Writing-package-vignettes

   What we need to do to convert/use the IRIDIA TR as the vignette?
   Move doc/irace.Rnw to inst/doc/. However, the problem is that R
   will try to recreate it in CRAN, so we have to include all the
   sources. That would mean also the sources for the IRIDIA TR covers.

 * Move the README information to the TR to avoid duplication.
 
 * Add inst/COPYRIGHTS. See race package.

TODO General:

 * Pass to hook-run/hook-evaluate an instance index that uniquely
   identifies each instance. This has two main advantages: 1) we can
   schedule jobs in parallel for different instances, e.g., execute
   all jobs for the first-test instances in parallel; 2) hook-run can
   use the index to assign a unique seed to each instance.

 * Make the output at beginning of iteration conditional on what is
   the tuning goal (time or nb evaluation). For instance it can be
   confusing for a newbie user to see "timeUsedSoFar" and
   "timeEstimate" always equal to zero, without knowing that they have
   no meaning for him (if he's tuning for nb evaluation).
   
 * Add errors for stupid parameter files. For example:
   
      x "" r (1e-4, 5e-4) # with digits=2 this is equal to (0, 0)
      y "" i (-1, -2) # the first value should be strictly smaller
      z "" c ("a", "a") # Two times the same value!

 * race package has some recent updates. Check with Mauro what he
   changed.

 * Implement some kind of immediate rejection handling, that is, if
   hook.run returns +Inf, just discard the candidate immediately
   without doing any more tests.

 * Implement a regression testing testsuite to check that everything
   is working as expect before making a release. See:

    - tests subdirectory in http://cran.r-project.org/doc/manuals/R-exts.html#Package-subdirectories
   - http://cran.r-project.org/web/packages/RUnit/index.html
   - http://cran.r-project.org/web/packages/svUnit/index.html

 * Implement a test mode that allows the user to check his set-up is
   correct (checking the configuration can be read, giving the number
   of iterations\candidates that would be used, calling hook-run
   once...).
   
 * Fix all FIXMEs.

 * Boolean command-line parameters require to provide a value
   (1/0). It would be nice if they could be enabled just by using
   them, that is, in addition to "--mpi 1" and "--mpi 0", accept just
   "--mpi".

 * Do not print anything about timeEstimate/timeUsedSoFar if it is
   never used (it is ever used?)

 * Make tune-main, tune-main-cluster, tune-main-mpi and other scripts
   use /tmp as much as possible.

 * How to avoid that MPI creates so many log files?

 * irace.Rdata should keep a list with the all the eliteCandidates after each
   race. Right now we only keep the best one.

 * Fix issues with digits, rounding and real parameters. If digits=d,
   perhaps it is more correct to sample like:

   round(rtnorm(1, mean + (10^-d) / 2, lower, upper + 10^-d) - (10^-d)/2, d)

   The same applies to runif().   

 * Handle properly fixed parameters in candidatesFile (see FIXME in
   readConfigurations.R).

 * Add command-line option --cluster=[sge|pbs] to choose the type of
   cluster. Then, hook-run calls qsub and prints a jobID. jobID must
   be a single word ([0-9a-z._-@]+); if not or length(jobID) != 1 or
   exit code is != 0, then complain. The option --cluster only chooses
   which type of qstat command is invoked. This will leave parsing the
   jobID to the user, since it is very fragile. We should put examples
   for PBS and SGE in examples/cluster-mode/.

 * generateCandidatesNormal() takes too much time with >800 candidates
   and >20 parameters (SPEAR testcase).
 
 * Use the options() mechanism of R, that is, 
   options(irace.debug.level = 1) and getOption("irace.debug.level").

 * Implement constraints on values that allow the user to specify
   restrictions on the values that parameters may take, such as all
   candidates must satisfy that a < b. Such constraints would be
   specified in a different file "constraints.txt". One way to handle
   them would be by sampling and rejection but perhaps more effective
   methods could be implemented.

 * JEREMIE: I would like to try a version of I-Race with a kind of
   bounding in the probability vectors, something equivalent somehow
   to MaxMin AS for ACO.  This could be a better way to avoid
   convergence than trying to "flat" the vectors when it is already
   too late.

 * JEREMIE: The way we handle initial candidates is to simply inject
   them among other candidates generated randomly. When we know some
   very good initial candidates, it could be interesting to sample the
   remaining ones from them. In other words, to consider the
   candidates provided as we consider elites between races. This would
   easily allows to hot-start a tuning with the results of a previous
   one. I have a real need for this.

 * JEREMIE: AFAK, there are very few (no?) state-of-the-art algorithms
   in optimization that do not use local search. I am not aware of any
   GA, for instance, that cannot be outperformed by its memetic
   counter-part. This is a strong motivation to try to include a
   local-search component into irace, since irace is performing search
   rather globally. I would like to implement a quick&dirty
   improvement of the winner at the end, testing values slightly
   smaller/bigger, parameter by parameter (at least 'r', 'i' and 'o'
   ones). Should not requires much evaluations.
  
 * Somehow adapt how many instances should be seen.  Maybe such
   choices should be done based on the perceived heterogeneity of the
   instances; I think this is an issue we also could discuss. I also
   think that one should be able to measure such things e.g. by the
   variability of the results of same configurations or by some
   measure of variation of ranks on instances for each configuration.

 * Various initialization modes Latin Hyper-cube, random, exhaustive,
   etc.

 * If we have too many elites, remove some of them. Add a parameter
   --max-elites.
 
 * Add example of logarithmic/parameter conversions in hook-run.

 * Resample / Randomize only the instances one has seen. When a race
   stops, the instances already seen are randomized but the elite
   configurations are not reevaluated on them.

 * Parameters should be printed and put in the commandline in exactly
   the same order given in the parameter file.

 * oneParamUpperBound and oneParamLowerBound are too much. We can
   have a single function: paramBound that returns 
      return (as.numeric(parameters[["boundary"]][[paramName]]))
   then the user can use directly [1] or [2] to select whatever they
   want. [Jeremie]

 * Forbidden parameter combinations (following ParamILS).

 * Error/Warn about unknown parameters.

 * Error messages start in uppercase and finish with a period.

 * Use tunerError() for user-level errors and irace.assert() for
   internal assertions. All stopfinot() should be irace.assert(). Some
   stop() should be tunerError(), a few should be irace.assert(). None
   of these functions nor cat() require pasting their arguments.

 * Do not add extra parenthesis around simple expressions. Example:
      if ( (!file.exists(installDir)) ) has too many parenthesis.

 * It could be nice to be able to set a different nb of rounding
   digits for each real parameters This number thus would be given in
   the parameters.txt file.  It should require very few
   modifications, only in the sampling (generation uniform and normal)

 * Add a hook that after sampling post-processes the candidates.

 * Make the update model convergence take into account the hierarchy
   of parameters.

------------------------------------------------------------------------------

DONE:

 * [DONE] We should use list$element instead of list[["element"]] for
   indexing elements that must exist. This way if we do a typo, the
   whole thing fails to run instead of just returning
   NULL. Unfortunately, list$__element__ does not work because
   __element__ is not a valid R variable name, so I suggest .ID.,
   which is valid.

 * [DONE] We should produce at least the ouput files in R data format
   using save()
    * A data.frame/matrix with all experiments performed.
    * A data.frame/matrix with all candidate results.
   [Manuel]

 * [FIXED] Use the remaining budget always. But how? 

 * [DONE] Allow to specify candidate configurations. Perhaps from an extra
   input file --candidates=candidates.txt, which gives one candidate
   per line in a table format:

       param1 param2 param3 param4
       10     5      none      8.2
       9      NA     all       8.3

   We would have to check that param names correspond to all
   parameters given in parameters.txt and that constraints are
   satisfied.

 * [DONE] The "c" is not "component" but "categorical". We should rename
   everything Component to Categorical, just use sed, check the diff
   and test. [Jeremie]

 * [DONE] If we want to keep the functions for isReal, isInteger, etc. then
   you should use them everywhere. I would propose to have a paramType
   function that returns the type, and then isReal(type) would just
   test (type == "r"). [Jeremie]

 * [DONE] Replace the constraints specifications by an R expression
   using: eval(parse(text=constraint), list(a=4, b=3))

 * In race.R: 

  - [DONE] I wonder why first.test should be a single number? It seems
    reasonable to choose 10 or more, no? I changed it in the check of
    the variable first.test

  - [DONE] Add a parameter each.test, to set how often the f-test
    should be performed, and the corresponding test. For example, if
    each.test == 10, the f-test will be performed only after having
    seen 10, 20, 30... instances.

 * [DONE] Print elite commandlines (that is, pairs switch-value) for easy
   copy-paste.

 * Remove the c() from all calls to printMsg. [DONE]

 * I think the concept of ghosts parameters could be better handled if
   we track the size of the domain of a parameter. Then, we do not
   sample/update probabilities for parameters whose domain is size
   1. Also, "ghost" is confusing, better would be "Fixed" or "Static".[DONE]

 * Rename everything as irace instead ifrace (only after merging all
   pending branches!). [DONE]

 * Reduce the output of the race package. Only report copyright info
   once. Do not duplicate information already given by irace. 
   [DONE by Jeremie]



------------------------------------------------------------------------------
